{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Godot 4 + GDScript-First Template","text":"<p>Welcome! This template uses GDScript-first gameplay with deterministic seams for testing, replays, and optional Rust acceleration.</p>"},{"location":"#what-you-get","title":"What You Get","text":"<ul> <li>\u2705 GDScript deterministic seam in <code>godot/core/</code> with <code>step()</code>, <code>decide()</code>, <code>generate()</code></li> <li>\u2705 Fixture testing with JSON golden tests in <code>godot/tests/fixtures/</code></li> <li>\u2705 Docker dev environment with all tools pre-configured</li> <li>\u2705 Optional Rust acceleration in <code>rust/</code> with GDExtension bridge</li> <li>\u2705 Automation-first commands (<code>make dev-ci</code> runs everything in Docker)</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code># Docker (recommended) - no local tools needed\nmake dev-validate\n\n# Or with local tools\nmake ci\n</code></pre> <p>Expected output: <pre><code>[FIXTURE OK] step_basic.json\n[FIXTURES OK] 3 passed\n[SMOKE OK]\n</code></pre></p>"},{"location":"#where-to-go-next","title":"Where to Go Next","text":"<ul> <li>Getting Started: Install Docker and run your first validation</li> <li>Architecture: Understand the deterministic seam pattern</li> <li>Tooling: Command reference and workflow tips</li> <li>Project Structure: Directory layout and conventions</li> <li>Rust + GDExtension Guide: Optional Rust acceleration</li> </ul>"},{"location":"#key-concepts","title":"Key Concepts","text":""},{"location":"#the-coreapi-seam","title":"The CoreAPI Seam","text":"<p>All game logic flows through a single function: <pre><code>var next_state = CoreAPI.step(current_state, {\"delta\": 1})\n</code></pre></p> <p>This enables: - Fixture testing: JSON files define input \u2192 expected output - Deterministic replays: Same inputs = same outputs - Rust migration: Swap implementation behind the seam</p>"},{"location":"architecture/","title":"Architecture: Deterministic Seams","text":"<p>This template uses a GDScript-first approach with deterministic seams that enable testing, replays, and future Rust migration.</p>"},{"location":"architecture/#core-concept-the-seam-pattern","title":"Core Concept: The Seam Pattern","text":"<p>All game logic flows through a single function:</p> <pre><code># godot/core/core_api.gd\nstatic func step(state: Dictionary, inp: Dictionary) -&gt; Dictionary:\n    var next := state.duplicate(true)\n    var delta := int(inp.get(\"delta\", 1))\n    next[\"tick\"] = int(next.get(\"tick\", 0)) + delta\n    return next\n</code></pre> <p>Key properties: - Pure-data in/out: Only dictionaries, no Node references - No side effects: Same inputs always produce same outputs - Deterministic: Enables fixture testing and replays</p>"},{"location":"architecture/#why-this-pattern","title":"Why This Pattern?","text":""},{"location":"architecture/#1-fixture-testing","title":"1. Fixture Testing","text":"<p>Test game logic without running Godot: <pre><code>{\n  \"initial_state\": { \"tick\": 0 },\n  \"input\": { \"delta\": 2 },\n  \"expected_state\": { \"tick\": 2 }\n}\n</code></pre></p>"},{"location":"architecture/#2-deterministic-replays","title":"2. Deterministic Replays","text":"<p>Record inputs \u2192 replay produces identical game state: <pre><code># SimClock can batch-run ticks\nvar final_state = SimClock.run_ticks(initial_state, recorded_inputs, 1000)\n</code></pre></p>"},{"location":"architecture/#3-ai-training","title":"3. AI Training","text":"<p>The seam is perfect for ML training loops: <pre><code># Python can call the same step() logic\nfor _ in range(1000):\n    state = core.step(state, ai.decide(state))\n</code></pre></p>"},{"location":"architecture/#4-rust-migration-path","title":"4. Rust Migration Path","text":"<p>Swap implementation without changing callers: <pre><code>static func step(state: Dictionary, inp: Dictionary) -&gt; Dictionary:\n    if use_rust():\n        return RustCore.step(state, inp)  # Rust implementation\n    else:\n        # GDScript implementation\n        var next := state.duplicate(true)\n        ...\n</code></pre></p>"},{"location":"architecture/#the-three-seams","title":"The Three Seams","text":""},{"location":"architecture/#stepstate-input-new_state","title":"<code>step(state, input) -&gt; new_state</code>","text":"<p>The main simulation tick. Advances game state by one frame.</p> <pre><code>var state = {\"tick\": 0, \"health\": 100}\nvar input = {\"action\": \"attack\", \"target\": 42}\nvar next_state = CoreAPI.step(state, input)\n# next_state = {\"tick\": 1, \"health\": 100, ...}\n</code></pre>"},{"location":"architecture/#decidestate-decision","title":"<code>decide(state) -&gt; decision</code>","text":"<p>AI decision-making. Returns what action to take given current state.</p> <pre><code>var state = {\"tick\": 50, \"enemies\": [...], \"player_pos\": Vector2(100, 200)}\nvar decision = CoreAPI.decide(state)\n# decision = {\"action\": \"move\", \"direction\": Vector2(1, 0)}\n</code></pre>"},{"location":"architecture/#generateseed-params-content","title":"<code>generate(seed, params) -&gt; content</code>","text":"<p>Procedural generation. Creates content deterministically from a seed.</p> <pre><code>var level = CoreAPI.generate(12345, {\"width\": 100, \"height\": 100, \"difficulty\": 3})\n# level = {\"tiles\": [...], \"enemies\": [...], \"items\": [...]}\n</code></pre>"},{"location":"architecture/#file-organization","title":"File Organization","text":"<pre><code>godot/core/\n\u251c\u2500\u2500 core_api.gd     # The three seams: step, decide, generate\n\u251c\u2500\u2500 schema.gd       # JSON normalization, validation helpers\n\u2514\u2500\u2500 sim_clock.gd    # Batch simulation driver\n\ngodot/tests/\n\u2514\u2500\u2500 fixtures/       # JSON test files\n    \u251c\u2500\u2500 step_basic.json\n    \u2514\u2500\u2500 step_edge_cases.json\n</code></pre>"},{"location":"architecture/#data-contracts","title":"Data Contracts","text":""},{"location":"architecture/#state-dictionary","title":"State Dictionary","text":"<p>Game state is a flat dictionary with primitives: <pre><code>{\n    \"tick\": 0,           # Current simulation tick\n    \"seed\": 12345,       # RNG seed for reproducibility\n    \"health\": 100,       # Player health\n    \"position_x\": 0.0,   # Use primitives, not Vector2\n    \"position_y\": 0.0,\n}\n</code></pre></p> <p>Rules: - Only use: <code>int</code>, <code>float</code>, <code>String</code>, <code>bool</code>, <code>Array</code>, <code>Dictionary</code> - No Godot types: <code>Vector2</code>, <code>Node</code>, <code>Resource</code> - Flat structure preferred for easy serialization</p>"},{"location":"architecture/#input-dictionary","title":"Input Dictionary","text":"<p>Per-tick input: <pre><code>{\n    \"delta\": 1,          # Tick delta (usually 1)\n    \"action\": \"move\",    # Player action\n    \"direction_x\": 1.0,  # Input direction\n    \"direction_y\": 0.0,\n}\n</code></pre></p>"},{"location":"architecture/#testing-workflow","title":"Testing Workflow","text":"<ol> <li>Write the logic in <code>godot/core/core_api.gd</code></li> <li>Create a fixture in <code>godot/tests/fixtures/my_test.json</code></li> <li>Run tests: <code>make dev-fixtures</code></li> </ol> <pre><code>// godot/tests/fixtures/attack_reduces_health.json\n{\n  \"initial_state\": { \"tick\": 0, \"health\": 100 },\n  \"input\": { \"action\": \"take_damage\", \"damage\": 25 },\n  \"expected_state\": { \"tick\": 1, \"health\": 75 }\n}\n</code></pre>"},{"location":"architecture/#migration-to-rust","title":"Migration to Rust","text":"<p>When performance matters, implement the seam in Rust:</p> <pre><code>// rust/core/src/lib.rs\npub fn step(state: HashMap&lt;String, Value&gt;, input: HashMap&lt;String, Value&gt;) -&gt; HashMap&lt;String, Value&gt; {\n    let mut next = state.clone();\n    let delta = input.get(\"delta\").unwrap_or(&amp;Value::Int(1)).as_i64().unwrap();\n    let tick = next.get(\"tick\").unwrap_or(&amp;Value::Int(0)).as_i64().unwrap();\n    next.insert(\"tick\".to_string(), Value::Int(tick + delta));\n    next\n}\n</code></pre> <p>Then update the GDScript seam to dispatch: <pre><code>static func step(state: Dictionary, inp: Dictionary) -&gt; Dictionary:\n    if use_rust():\n        var rust_core = ClassDB.instantiate(\"RustCore\")\n        return rust_core.step(state, inp)\n    else:\n        # GDScript fallback\n        ...\n</code></pre></p> <p>Run the same fixtures against both implementations to verify equivalence.</p>"},{"location":"architecture/#scaling-patterns","title":"Scaling Patterns","text":"<p>As your game grows, evolve the architecture in phases. Each phase builds on the previous while maintaining the deterministic seam contract.</p>"},{"location":"architecture/#current-typed-resources","title":"Current: Typed Resources","text":"<p>The template now uses typed Resource classes for state and input:</p> <pre><code># godot/core/resources/game_state.gd\nclass_name GameState extends Resource\n\n@export var tick: int = 0\n@export var seed_val: int = 0\n\nstatic func from_dict(data: Dictionary):\n    # Convert from JSON/Dictionary\n    ...\n\nfunc to_dict() -&gt; Dictionary:\n    # Convert to JSON/Dictionary\n    return {\"tick\": tick, \"seed_val\": seed_val}\n</code></pre> <p>Benefits: - Autocomplete and type checking in editor - Explicit field definitions (no magic strings) - 1:1 mapping to Rust structs - Resources still serialize through <code>to_dict()</code> for fixtures</p> <p>Usage: <pre><code># Dictionary API (for fixtures, JSON interop)\nvar next = CoreAPI.step({\"tick\": 0, \"seed_val\": 0}, {\"delta\": 1})\n\n# Typed API (for game code)\nvar state = GameState.from_dict({\"tick\": 0})\nvar input = GameInput.from_dict({\"delta\": 1})\nvar next_state = CoreAPI.step_typed(state, input)\n</code></pre></p>"},{"location":"architecture/#phase-2-entity-resources","title":"Phase 2: Entity Resources","text":"<p>When you need multiple game objects, add an Entity Resource:</p> <pre><code># godot/core/resources/entity.gd\nclass_name Entity extends Resource\n\n@export var id: int = 0\n@export var position_x: float = 0.0\n@export var position_y: float = 0.0\n@export var health: int = 100\n\nstatic func from_dict(data: Dictionary):\n    var e = Entity.new()\n    e.id = int(data.get(\"id\", 0))\n    e.position_x = float(data.get(\"position_x\", 0.0))\n    e.position_y = float(data.get(\"position_y\", 0.0))\n    e.health = int(data.get(\"health\", 100))\n    return e\n\nfunc to_dict() -&gt; Dictionary:\n    return {\n        \"id\": id,\n        \"position_x\": position_x,\n        \"position_y\": position_y,\n        \"health\": health\n    }\n</code></pre> <p>Update GameState to include entities: <pre><code>@export var entities: Dictionary = {}  # id -&gt; Entity\n\nfunc to_dict() -&gt; Dictionary:\n    var ents = {}\n    for id in entities:\n        ents[str(id)] = entities[id].to_dict()\n    return {\"tick\": tick, \"seed_val\": seed_val, \"entities\": ents}\n</code></pre></p>"},{"location":"architecture/#phase-3-systems-decomposition","title":"Phase 3: Systems Decomposition","text":"<p>When <code>step()</code> grows beyond ~100 lines, decompose into systems:</p> <pre><code># godot/core/systems/physics_system.gd\nclass_name PhysicsSystem\n\nstatic func step(state: GameState, input: GameInput) -&gt; void:\n    for entity in state.entities.values():\n        entity.position_x += entity.velocity_x * input.delta\n        entity.position_y += entity.velocity_y * input.delta\n</code></pre> <pre><code># godot/core/core_api.gd\nstatic func step_typed(state, inp):\n    var next = state.duplicate_state()\n    PhysicsSystem.step(next, inp)\n    CombatSystem.step(next, inp)\n    AISystem.step(next, inp)\n    return next\n</code></pre> <p>When to add systems: - Multiple distinct domains (physics, combat, AI) - Code becomes hard to navigate - Different tick rates needed (physics every frame, AI every 10 frames)</p>"},{"location":"architecture/#rust-migration-path","title":"Rust Migration Path","text":"<p>Each pattern maps directly to Rust:</p> GDScript Rust <code>class_name GameState extends Resource</code> <code>struct GameState</code> <code>@export var tick: int</code> <code>pub tick: i32</code> <code>static func from_dict(...)</code> <code>impl From&lt;HashMap&lt;...&gt;&gt;</code> <code>func to_dict()</code> <code>impl Into&lt;HashMap&lt;...&gt;&gt;</code> <code>PhysicsSystem.step(state, input)</code> <code>physics::step(&amp;mut state, &amp;input)</code> <p>When migrating: 1. Implement the Rust struct matching the Resource 2. Add <code>serde</code> for JSON serialization 3. Expose through GDExtension bridge 4. Run same fixtures to verify equivalence 5. Swap implementation in <code>CoreAPI.step()</code></p>"},{"location":"architecture/#what-to-skip","title":"What to Skip","text":"<p>Don't add until you need it: - Full ECS (Bevy-style) - overkill for most games - Node-based state - harder to migrate - Complex inheritance - Rust prefers composition - Generic systems framework - YAGNI</p> <p>Keep it simple: - Start with typed Resources (current state) - Add entities when you have multiple game objects - Add systems when step() gets unwieldy - Migrate to Rust when you need performance</p>"},{"location":"container-setup/","title":"Container Setup Guide","text":"<p>This project supports both Docker and Podman for containerized development.</p>"},{"location":"container-setup/#quick-start","title":"Quick Start","text":"<p>The Makefile automatically detects your container engine:</p> <pre><code># Automatic detection (prefers Podman if available)\nmake dev-env\n\n# Explicit engine selection\nCONTAINER_ENGINE=docker make dev-env\nCONTAINER_ENGINE=podman make dev-env\n</code></pre>"},{"location":"container-setup/#podman-vs-docker","title":"Podman vs Docker","text":""},{"location":"container-setup/#key-differences","title":"Key Differences","text":"Feature Docker Podman Root privileges Runs as root by default Rootless by default Daemon Requires dockerd daemon Daemonless Security Good with proper setup Better default security Compose support Native Via podman-compose"},{"location":"container-setup/#when-to-use-which","title":"When to Use Which","text":"<p>Use Docker when: - It's your team's standard - You need Docker Desktop features - You're using Docker-specific tooling</p> <p>Use Podman when: - Security is a top priority - You can't/don't want to run a daemon - You're in a restricted environment</p>"},{"location":"container-setup/#troubleshooting","title":"Troubleshooting","text":""},{"location":"container-setup/#permission-issues","title":"Permission Issues","text":"<p>If you encounter permission issues with mounted volumes:</p> <ol> <li>For Podman: Should work automatically with rootless mode</li> <li>For Docker: Set your UID/GID in <code>docker/.env</code>:    <pre><code>echo \"UID=$(id -u)\" &gt;&gt; docker/.env\necho \"GID=$(id -g)\" &gt;&gt; docker/.env\n</code></pre></li> </ol>"},{"location":"container-setup/#socket-issues","title":"Socket Issues","text":"<p>If Podman can't find the Docker socket:</p> <pre><code># Set the socket path in your .env\necho \"DOCKER_SOCK=${XDG_RUNTIME_DIR}/podman/podman.sock\" &gt;&gt; docker/.env\n</code></pre>"},{"location":"container-setup/#compose-command-not-found","title":"Compose Command Not Found","text":"<p>For Podman, you need to install podman-compose:</p> <pre><code># macOS\nbrew install podman-compose\n\n# Linux\npip install podman-compose\n</code></pre>"},{"location":"container-setup/#podman-machine-not-running-macoswindows","title":"Podman Machine Not Running (macOS/Windows)","text":"<p>Podman needs a Linux VM to run containers. The Makefile will automatically start it, but you can also manage it manually:</p> <pre><code># Initialize a new machine\npodman machine init\n\n# Start the machine\npodman machine start\n\n# Check machine status\npodman machine list\n\n# Stop the machine\npodman machine stop\n</code></pre>"},{"location":"container-setup/#auto-setup-with-make","title":"Auto-Setup with Make","text":"<p>The project's Makefile handles most Podman setup automatically:</p> <ul> <li>Checks if Podman machine is running</li> <li>Starts it if needed</li> <li>Verifies podman-compose is installed</li> <li>Uses appropriate socket paths</li> </ul> <p>Just run <code>make container-info</code> to see the current status.</p>"},{"location":"container-setup/#compatibility-with-project-initialization","title":"Compatibility with Project Initialization","text":"<p>The container setup is designed to work both before and after running <code>make init</code>:</p>"},{"location":"container-setup/#before-make-init","title":"Before <code>make init</code>","text":"<ul> <li>Source code is in <code>src/</code> directory</li> <li>Container mounts entire project as <code>/workspace</code></li> <li>All development tools work normally</li> </ul>"},{"location":"container-setup/#after-make-init","title":"After <code>make init</code>","text":"<ul> <li>Source code moves to your project module directory (e.g., <code>my_project/</code>)</li> <li>Container setup continues to work unchanged</li> <li>Volume mounts and dependencies remain intact</li> </ul> <p>The <code>make init</code> command: 1. Renames <code>src/</code> to your project name 2. Updates import statements in tests 3. Modifies <code>pyproject.toml</code> and <code>Makefile</code></p> <p>The Docker/Podman setup survives this transformation because: - The Dockerfile doesn't hardcode directory names - Dependencies are installed from temporary copied files - The entire project is mounted, regardless of internal structure</p> <p>This means you can: <pre><code># Set up development environment\nmake dev-env\n\n# Initialize your project later\nmake init\n\n# Continue using the same development environment\nmake dev-env  # Still works!\n</code></pre></p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide covers two paths: Docker (recommended) for a zero-setup experience, or local installation if you prefer native tools.</p>"},{"location":"getting-started/#option-a-docker-dev-environment-recommended","title":"Option A: Docker Dev Environment (Recommended)","text":"<p>No local tool installation required. Just Docker.</p>"},{"location":"getting-started/#1-install-docker","title":"1) Install Docker","text":"<ul> <li>macOS: Install Docker Desktop or Colima</li> <li>Linux: <code>apt install docker.io docker-compose</code> or equivalent</li> <li>Windows: Install Docker Desktop with WSL2</li> </ul>"},{"location":"getting-started/#2-validate-everything-works","title":"2) Validate Everything Works","text":"<pre><code>make dev-validate\n</code></pre> <p>This builds the container and runs the full CI suite. Expected output: <pre><code>=== Rust === rustc 1.92.0 ...\n=== Godot === 4.5.1.stable\n[SMOKE OK]\nDev environment fully validated\n</code></pre></p>"},{"location":"getting-started/#3-daily-workflow","title":"3) Daily Workflow","text":"<pre><code># Full CI (Rust + GDScript)\nmake dev-ci\n\n# Just GDScript fixture tests\nmake dev-fixtures\n\n# Interactive shell for debugging\nmake dev-shell\n</code></pre> <p>You're done! Skip to Next Steps.</p>"},{"location":"getting-started/#option-b-local-installation","title":"Option B: Local Installation","text":"<p>If you prefer native tools over Docker.</p>"},{"location":"getting-started/#1-install-rust","title":"1) Install Rust","text":"<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nsource \"$HOME/.cargo/env\"\n\nrustup default stable\nrustup component add clippy rustfmt\n</code></pre>"},{"location":"getting-started/#2-install-godot-4","title":"2) Install Godot 4","text":"<p>Download Godot 4.5+ and add to PATH: <pre><code>godot --version\n# Should output: 4.5.x.stable\n</code></pre></p>"},{"location":"getting-started/#3-validate","title":"3) Validate","text":"<pre><code>make ci\n</code></pre> <p>Expected output: <pre><code>test tests::ping_formats ... ok\n[SMOKE OK]\n</code></pre></p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":""},{"location":"getting-started/#learn-the-architecture","title":"Learn the Architecture","text":"<p>Read Architecture: Deterministic Seams to understand the <code>CoreAPI.step()</code> pattern.</p>"},{"location":"getting-started/#add-game-logic","title":"Add Game Logic","text":"<ol> <li>Edit <code>godot/core/core_api.gd</code></li> <li>Add a fixture test in <code>godot/tests/fixtures/</code></li> <li>Run <code>make dev-fixtures</code></li> </ol>"},{"location":"getting-started/#explore-the-codebase","title":"Explore the Codebase","text":"<pre><code>godot/core/          # GDScript game logic seam\ngodot/tests/fixtures/# JSON fixture tests\nrust/core/           # Optional Rust acceleration\n</code></pre>"},{"location":"getting-started/#common-commands","title":"Common Commands","text":"Command Description <code>make dev-ci</code> Full CI in Docker <code>make dev-fixtures</code> GDScript fixture tests <code>make dev-shell</code> Interactive debugging <p>See Tooling &amp; Automation for the complete command reference.</p>"},{"location":"project-structure/","title":"Project Structure","text":"<p>This template uses GDScript-first gameplay with optional Rust acceleration.</p>"},{"location":"project-structure/#recommended-layout","title":"Recommended Layout","text":"<pre><code>repo/\n\u251c\u2500\u2500 godot/                        # Godot project root\n\u2502   \u251c\u2500\u2500 project.godot              # Project settings\n\u2502   \u251c\u2500\u2500 core/                      # Deterministic seam (GDScript)\n\u2502   \u2502   \u251c\u2500\u2500 core_api.gd            # step(), decide(), generate()\n\u2502   \u2502   \u251c\u2500\u2500 schema.gd              # JSON normalization helpers\n\u2502   \u2502   \u2514\u2500\u2500 sim_clock.gd           # Batch simulation driver\n\u2502   \u251c\u2500\u2500 scenes/                    # Scene files (.tscn)\n\u2502   \u251c\u2500\u2500 scripts/                   # GDScript files (.gd)\n\u2502   \u2502   \u251c\u2500\u2500 Main.gd                # Game script (uses CoreAPI)\n\u2502   \u2502   \u251c\u2500\u2500 smoke_test.gd          # Headless smoke test\n\u2502   \u2502   \u2514\u2500\u2500 run_fixtures.gd        # Fixture test runner\n\u2502   \u251c\u2500\u2500 tests/\n\u2502   \u2502   \u2514\u2500\u2500 fixtures/              # Golden test JSON files\n\u2502   \u2502       \u2514\u2500\u2500 step_basic.json\n\u2502   \u2514\u2500\u2500 addons/\n\u2502       \u2514\u2500\u2500 my_ext/                # GDExtension (optional)\n\u2502           \u251c\u2500\u2500 my_ext.gdextension\n\u2502           \u2514\u2500\u2500 bin/linux/debug/libmy_ext.so\n\u251c\u2500\u2500 rust/                          # Optional Rust acceleration\n\u2502   \u251c\u2500\u2500 Cargo.toml\n\u2502   \u251c\u2500\u2500 core/                      # Pure Rust logic + tests\n\u2502   \u2514\u2500\u2500 gdext_bridge/              # Thin GDExtension bridge\n\u251c\u2500\u2500 docker/\n\u2502   \u251c\u2500\u2500 Dockerfile                 # Dev container with all tools\n\u2502   \u2514\u2500\u2500 docker-compose.yml\n\u251c\u2500\u2500 docs/\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"project-structure/#key-ideas","title":"Key Ideas","text":""},{"location":"project-structure/#gdscript-first-with-deterministic-seams","title":"GDScript-First with Deterministic Seams","text":"<ul> <li><code>godot/core/</code>: All game logic flows through <code>CoreAPI.step(state, input)</code></li> <li>Pure-data in/out: Dictionaries only, no Node references, no side effects</li> <li>Fixture testing: JSON files define input \u2192 expected output</li> </ul>"},{"location":"project-structure/#optional-rust-acceleration","title":"Optional Rust Acceleration","text":"<ul> <li>Core: deterministic logic, easy to test with <code>cargo test</code></li> <li>Bridge: minimal marshaling between Godot and Rust</li> <li>Migration path: Swap GDScript implementation for Rust behind the seam</li> </ul>"},{"location":"project-structure/#keep-scripts-close-to-scenes","title":"Keep Scripts Close to Scenes","text":"<pre><code>scenes/player/Player.tscn\nscripts/player/Player.gd\n</code></pre>"},{"location":"project-structure/#gdextension-files-are-part-of-the-build-contract","title":"GDExtension Files Are Part of the Build Contract","text":"<p>Treat the <code>.gdextension</code> file and the <code>addons/my_ext/bin/</code> layout as critical build artifacts.</p>"},{"location":"rust-gdext/","title":"Rust + GDExtension Guide (Fast Core, Thin Bridge)","text":"<p>This project follows a fast-core + thin-bridge architecture:</p> <ul> <li><code>rust/core</code> owns deterministic gameplay logic and tests.</li> <li><code>rust/gdext_bridge</code> is a minimal GDExtension surface that marshals data between Godot and the core.</li> <li>Godot scenes/UI remain in GDScript or minimal Rust classes.</li> </ul>"},{"location":"rust-gdext/#architecture-principles","title":"Architecture Principles","text":"<ol> <li>Fast iteration loop</li> <li>90% of changes land in <code>rust/core</code>.</li> <li><code>cargo test -p core</code> is the primary feedback loop.</li> <li>Thin GDExtension bridge</li> <li>Keep Godot-specific types in the bridge only.</li> <li>Expose a narrow API to GDScript.</li> <li>Deterministic automation</li> <li><code>make ci</code> runs fmt, clippy, tests, builds the extension, and runs a headless smoke test.</li> </ol>"},{"location":"rust-gdext/#gdextension-contract","title":"GDExtension Contract","text":"<p>The extension is loaded by <code>godot/addons/my_ext/my_ext.gdextension</code> and expects the entry symbol: <pre><code>entry_symbol = \"gdext_rust_init\"\n</code></pre> The compiled library is copied into: <pre><code>godot/addons/my_ext/bin/linux/debug/libmy_ext.so\n</code></pre></p>"},{"location":"rust-gdext/#rust-workspace-layout","title":"Rust Workspace Layout","text":"<pre><code>rust/\n\u251c\u2500\u2500 Cargo.toml        # workspace members: core, gdext_bridge\n\u251c\u2500\u2500 core/             # pure Rust logic + tests\n\u2514\u2500\u2500 gdext_bridge/     # GDExtension bridge (cdylib)\n</code></pre>"},{"location":"rust-gdext/#smoke-test","title":"Smoke Test","text":"<p>The headless smoke test (<code>godot/scripts/smoke_test.gd</code>) verifies:</p> <ol> <li>The extension loads.</li> <li><code>RustSmoke</code> is instantiable.</li> <li><code>RustSmoke.ping(\"hi\")</code> returns <code>\"hi -&gt; pong\"</code>.</li> </ol> <p>Run it with: <pre><code>make smoke\n</code></pre></p>"},{"location":"rust-gdext/#headless-caveat-import-timing","title":"Headless Caveat (Import Timing)","text":"<p>On CI, imports can race if the project exits too quickly. The smoke test is intentionally small but should be the last step in CI to ensure imports finish.</p>"},{"location":"rust-gdext/#acceptance-checklist","title":"Acceptance Checklist","text":"<ul> <li>[ ] <code>make test</code> runs <code>cargo test -p core</code> quickly.</li> <li>[ ] <code>make smoke</code> passes headless without opening a window.</li> <li>[ ] <code>make ci</code> succeeds on Linux in a fresh clone.</li> <li>[ ] <code>.gdextension</code> paths match the copied artifacts.</li> </ul>"},{"location":"starter-pack/","title":"Starter Pack Tutorial: Your First Playable Scene","text":"<p>This tutorial builds a tiny 2D scene with player movement and a camera. It assumes zero Godot experience.</p>"},{"location":"starter-pack/#goals","title":"Goals","text":"<ul> <li>Add a player character</li> <li>Move with WASD / arrow keys</li> <li>Keep the camera centered</li> </ul>"},{"location":"starter-pack/#1-create-a-player-scene","title":"1. Create a Player Scene","text":"<ol> <li>In the FileSystem panel, create a new folder: <code>godot/scenes/player/</code>.</li> <li>Click Scene \u2192 New Scene.</li> <li>Add a CharacterBody2D node and name it <code>Player</code>.</li> <li>Add a child Sprite2D (for visuals) and CollisionShape2D (for collisions).</li> <li>Save the scene as <code>godot/scenes/player/Player.tscn</code>.</li> </ol>"},{"location":"starter-pack/#add-a-script","title":"Add a Script","text":"<p>Attach a new script to the <code>Player</code> node named <code>Player.gd</code> in <code>godot/scripts/</code>: <pre><code>extends CharacterBody2D\n\n@export var speed: float = 300.0\n\nfunc _physics_process(_delta: float) -&gt; void:\n    var input_vector = Vector2(\n        Input.get_action_strength(\"ui_right\") - Input.get_action_strength(\"ui_left\"),\n        Input.get_action_strength(\"ui_down\") - Input.get_action_strength(\"ui_up\")\n    )\n\n    velocity = input_vector.normalized() * speed\n    move_and_slide()\n</code></pre></p>"},{"location":"starter-pack/#2-update-the-main-scene","title":"2. Update the Main Scene","text":"<p>Open <code>godot/scenes/Main.tscn</code> and: 1. Add a Node2D named <code>World</code>. 2. Instance your new <code>Player.tscn</code> as a child of <code>World</code>. 3. Add a Camera2D as a child of <code>Player</code>. 4. Enable Current on the Camera2D so it becomes active.</p> <p>Your scene tree should look like: <pre><code>Main (Node2D)\n\u2514\u2500\u2500 World (Node2D)\n    \u2514\u2500\u2500 Player (CharacterBody2D)\n        \u251c\u2500\u2500 Sprite2D\n        \u251c\u2500\u2500 CollisionShape2D\n        \u2514\u2500\u2500 Camera2D\n</code></pre></p>"},{"location":"starter-pack/#3-run-the-game","title":"3. Run the Game","text":"<p>Press F5 to run the project. Your player should move with the arrow keys or WASD (Godot maps both to <code>ui_*</code> actions by default).</p>"},{"location":"starter-pack/#4-optional-add-a-floor","title":"4. Optional: Add a Floor","text":"<ol> <li>In <code>Main.tscn</code>, add a StaticBody2D with a CollisionShape2D.</li> <li>Use a RectangleShape2D and scale it to make a floor.</li> <li>Add a ColorRect or Sprite2D for visuals.</li> </ol>"},{"location":"starter-pack/#5-what-you-learned","title":"5. What You Learned","text":"<ul> <li>How to create scenes and instance them</li> <li>How to attach scripts to nodes</li> <li>How to move a character with built-in input actions</li> <li>How to keep the camera centered</li> </ul> <p>Next, review the Project Structure page to learn how to organize larger games.</p>"},{"location":"tooling/","title":"Tooling &amp; Automation","text":"<p>This page covers tools and workflows for Godot + GDScript + Rust development.</p>"},{"location":"tooling/#quick-reference","title":"Quick Reference","text":"Command Description <code>make dev-ci</code> Full CI in Docker (recommended) <code>make dev-fixtures</code> Run GDScript fixture tests in Docker <code>make dev-validate</code> Verify tools + run full CI <code>make dev-shell</code> Interactive shell in container <code>make ci</code> Full local CI (requires local tools) <code>make fixtures</code> Run GDScript fixture tests locally <code>make gdscript-ci</code> Smoke + fixtures (GDScript only)"},{"location":"tooling/#docker-dev-environment-recommended","title":"Docker Dev Environment (Recommended)","text":"<p>The Docker container includes all tools pre-configured: - Rust 1.92 + clippy + rustfmt - Godot 4.5.1 headless (ARM64/x86_64 auto-detected) - Python 3.11 + uv</p> <pre><code># First time setup\nmake dev-validate\n\n# Daily workflow\nmake dev-ci          # Full validation\nmake dev-fixtures    # Just GDScript tests\nmake dev-shell       # Interactive debugging\n</code></pre>"},{"location":"tooling/#gdscript-fixture-testing","title":"GDScript Fixture Testing","text":"<p>Fixtures are JSON files that define deterministic test cases:</p> <pre><code>{\n  \"initial_state\": { \"tick\": 0 },\n  \"input\": { \"delta\": 2 },\n  \"expected_state\": { \"tick\": 2 }\n}\n</code></pre> <p>Place fixtures in <code>godot/tests/fixtures/</code> and run: <pre><code>make dev-fixtures\n</code></pre></p> <p>Expected output: <pre><code>[FIXTURE OK] step_basic.json\n[FIXTURES OK] 3 passed\n</code></pre></p>"},{"location":"tooling/#rust-tooling","title":"Rust Tooling","text":"<p>Install Rust and enable fmt/clippy: <pre><code>rustup default stable\nrustup component add clippy rustfmt\n</code></pre></p> <p>Core tests: <pre><code>cargo test -p core\n</code></pre></p>"},{"location":"tooling/#makefile-commands","title":"Makefile Commands","text":""},{"location":"tooling/#gdscript-commands","title":"GDScript Commands","text":"<pre><code>make fixtures      # Run fixture tests\nmake gdscript-ci   # Smoke + fixtures\nmake smoke         # Build extension + smoke test\n</code></pre>"},{"location":"tooling/#rust-commands","title":"Rust Commands","text":"<pre><code>make fmt           # Format Rust code\nmake lint          # Run clippy\nmake test          # Run core tests\nmake build-ext     # Build GDExtension\n</code></pre>"},{"location":"tooling/#docker-commands","title":"Docker Commands","text":"<pre><code>make dev-ci            # Full CI in container\nmake dev-fixtures      # Fixtures in container\nmake dev-validate      # Tools check + full CI\nmake dev-shell         # Interactive bash\nmake dev-check-tools   # Verify tool versions\n</code></pre>"},{"location":"tooling/#recommended-plugins","title":"Recommended Plugins","text":"<ul> <li>GDUnit4 or GUT for automated tests</li> <li>Dialogic for narrative-heavy projects</li> <li>Godot-Redux or custom input remapping for accessibility</li> </ul> <p>Keep plugins in <code>godot/addons/</code> and commit to version control.</p>"},{"location":"tooling/#gdscript-formatting-linting","title":"GDScript Formatting &amp; Linting","text":"<p>Suggested tools: - gdformat (formatter) - gdlint (lint rules)</p> <pre><code>pip install godot-gdscript-toolkit\ngdformat godot/scripts\ngdlint godot/scripts\n</code></pre>"},{"location":"tooling/#headless-testing","title":"Headless Testing","text":"<p>Godot headless mode is used for CI: <pre><code># Smoke test\ngodot --headless --path godot --script res://scripts/smoke_test.gd\n\n# Fixture tests\ngodot --headless --path godot --script res://scripts/run_fixtures.gd\n</code></pre></p>"},{"location":"tooling/#build-checklist","title":"Build Checklist","text":"<ul> <li>\u2705 Rust fmt + clippy pass</li> <li>\u2705 <code>cargo test -p core</code> passes</li> <li>\u2705 Extension builds and copies into <code>godot/addons/my_ext/bin/</code></li> <li>\u2705 Headless smoke test passes</li> <li>\u2705 GDScript fixture tests pass</li> </ul>"},{"location":"reference/resources/","title":"Godot + Rust Resources","text":"<p>A curated starter list for Godot 4 + GDExtension development.</p>"},{"location":"reference/resources/#official-godot-docs","title":"Official Godot Docs","text":"<ul> <li>Godot Manual: https://docs.godotengine.org/en/stable/</li> <li>Class Reference: https://docs.godotengine.org/en/stable/classes/</li> <li>GDScript Basics: https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/</li> <li>Input Map: https://docs.godotengine.org/en/stable/tutorials/inputs/inputevent.html</li> <li>Headless/CLI: https://docs.godotengine.org/en/stable/tutorials/editor/command_line_tutorial.html</li> </ul>"},{"location":"reference/resources/#godot-rust-gdextension","title":"Godot + Rust (GDExtension)","text":"<ul> <li>godot-rust book: https://godot-rust.github.io/book/</li> <li>godot-rust repo: https://github.com/godot-rust/gdext</li> </ul>"},{"location":"reference/resources/#learning-paths","title":"Learning Paths","text":"<ul> <li>2D Game Tutorial: https://docs.godotengine.org/en/stable/getting_started/first_2d_game/</li> <li>3D Game Tutorial: https://docs.godotengine.org/en/stable/getting_started/first_3d_game/</li> </ul>"},{"location":"reference/resources/#testing-tooling","title":"Testing &amp; Tooling","text":"<ul> <li>GUT: https://github.com/bitwes/Gut</li> <li>GDUnit4: https://github.com/MikeSchulze/gdUnit4</li> <li>gdformat / gdlint: https://github.com/Scony/godot-gdscript-toolkit</li> <li>rust-cache: https://github.com/Swatinem/rust-cache</li> </ul>"},{"location":"reference/resources/#quick-reference-checklist","title":"Quick Reference Checklist","text":"<ul> <li>[ ] Core tests pass (<code>cargo test -p core</code>)</li> <li>[ ] Extension builds and copies into <code>godot/addons/my_ext/bin/</code></li> <li>[ ] Smoke test passes headless</li> <li>[ ] CI cache enabled for Rust builds</li> </ul>"}]}